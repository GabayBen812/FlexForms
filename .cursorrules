# Paradize Cursor Rules

## Project Overview
Paradize is a multi-tenant ERP/CRM platform with a React frontend and NestJS backend. This project uses TypeScript throughout, MongoDB for data storage, and modern tooling including Vite, Tailwind CSS, and React Query. also Radix UI - also shadcn/ui 
This will be dedicated for education organizations

When i write "FF" i usally refer to FeatureFlag

this project use Mixpanel and google analytics and SendGrid

Multi-tenant: The endpoint should use the organizationId from the JWT token,

## Project Structure

### Client (`/Client`)
- **Frontend Framework:** React 18+ with TypeScript
- **Build Tool:** Vite
- **Styling:** Tailwind CSS with Radix UI components - also shadcn/ui 
- **State Management:** React Query (@tanstack/react-query) for server state
- **Routing:** React Router v7
- **Internationalization:** i18next with support for English (en) and Hebrew (he)
- **Testing:** Cypress for E2E testing

### Server (`/Server`)
- **Backend Framework:** NestJS with Express
- **Database:** MongoDB with Mongoose
- **Authentication:** JWT-based authentication
- **Validation:** class-validator and class-transformer

### Mobile (`/apps/mobile`)
- **Framework:** React Native with Expo (SDK 54)
- **Styling:** NativeWind (Tailwind for React Native) + StyleSheet API
- **UI Components:** Gluestack UI (not shadcn/ui)
- **State Management:** React Query (@tanstack/react-query) for server state
- **Navigation:** React Navigation (Native Stack + Bottom Tabs)
- **Internationalization:** Support for English (en) and Hebrew (he) with RTL
- **Authentication:** JWT via SecureStore cookies

## Code Style & Conventions

### TypeScript
- Use strict TypeScript configuration
- Always define explicit types for function parameters and return values
- Prefer interfaces over types for object shapes that might be extended
- Use type inference only when the type is obvious from context
- Avoid `any` - use `unknown` if the type is truly unknown, then narrow it

### React/TypeScript (Client)
- Use functional components with hooks
- Follow React hooks rules strictly
- Use TypeScript for all components and utilities
- Prefer named exports over default exports
- Component files should use PascalCase (e.g., `UserProfile.tsx`)
- Use React Query for all server state management
- Use React Query cache 
- Regarding state: avoid duplicate states, prefer relivered state over local.
- invalidate Queries Instead Of Manual Refetch
- single Source Of Truth
- Keep components small and focused - extract logic into custom hooks when needed
- Use React.memo() sparingly, only when performance profiling shows it's needed

### React Native/TypeScript (Mobile)
- Use functional components with hooks (same as Client)
- Follow React hooks rules strictly
- Use TypeScript for all components and utilities
- Prefer named exports over default exports
- Component files should use PascalCase (e.g., `HomeScreen.tsx`)
- Use React Query for all server state management (same patterns as Client)
- Always use SafeAreaView for screens to handle notches/status bars
- Use Pressable with pressed states for interactive elements (not TouchableOpacity)
- Type navigation params using React Navigation's type system
- Keep components focused on mobile screen sizes (320px - 428px width)

### NestJS (Server)
- Follow NestJS module architecture patterns
- Use DTOs (Data Transfer Objects) for all API endpoints
- Validate all inputs using class-validator decorators
- Use dependency injection throughout
- Keep controllers thin - business logic belongs in services
- Use guards for authentication and authorization
- Use interceptors for cross-cutting concerns

### File Naming
- React components: PascalCase (e.g., `UserProfile.tsx`)
- Hooks: camelCase with `use` prefix (e.g., `useAuth.ts`)
- Utilities: camelCase (e.g., `formUtils.ts`)
- Types/interfaces: PascalCase (e.g., `User.ts`)
- Constants: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`)

### Folder Organization
- Group related files by feature, not by type
- Keep feature-specific files together (components, hooks, types, utils)
- Shared utilities go in `/lib` or `/utils`
- API-related code goes in `/api` with clear subfolder structure

## Best Practices

### API Client
- Use the centralized API client (`apiClient.ts` for Client, `api/client.ts` for Mobile) for all HTTP requests
- Organize API functions by feature in subfolders
- Always handle errors appropriately
- Use React Query hooks for data fetching and mutations
- Mobile: Use SecureStore for auth cookies, handle cookie management in API interceptors

### Internationalization
- All user-facing text must be internationalized using i18next (Client) or similar approach (Mobile)
- Use translation keys in the format: `namespace:key` (e.g., `common:save`)
- Keep translation keys organized by feature/namespace
- Support both RTL (Hebrew) and LTR (English) layouts
- Mobile: Ensure text alignment and flex direction support RTL properly

### Styling (Client - Web)
- Use shadcn/ui and Radix UI components
- Use Tailwind CSS utility classes
- Prefer Radix UI components for complex UI elements
- Use Tailwind's RTL support for Hebrew language support
- Keep custom CSS minimal - use Tailwind configuration for design tokens
- Use `cn()` utility (from `clsx` + `tailwind-merge`) for conditional classes

### Styling (Mobile - React Native)
- Use NativeWind for Tailwind-like utility classes (when convenient)
- Use StyleSheet.create() for component styles (preferred for performance)
- Use Gluestack UI components for complex UI elements (not shadcn/ui)
- Support RTL layouts - use `textAlign: 'right'` and `flexDirection: 'row-reverse'` for Hebrew
- Use SafeAreaView for all screens to handle device notches and status bars
- Ensure touch targets are at least 44x44 points for accessibility
- Use elevation and shadowColor for Android, shadowOpacity/shadowRadius for iOS
- Prefer flexbox layouts - mobile screens are constrained (320-428px width)
- Use LinearGradient from expo-linear-gradient for gradient buttons/backgrounds

### State Management
- Server state: React Query (@tanstack/react-query)
- Local component state: useState/useReducer
- Form state: React Hook Form
- Global client state: Context API (sparingly, only when truly needed)

### Feature Flags
- Use the `useFeatureFlag(key)` hook for single-flag checks and `useFeatureFlags(keys[])` when multiple flags are needed.
- Feature flag keys live on each route/component handle; derive the relevant keys once (e.g., via `useMemo`) and feed them into the hook.
- The hooks share a cache and automatically scope checks by `organizationId`, so reuse them everywhere (routing, menus, tab bars, dialogs) instead of bespoke logic.
- When filtering UI (like the Topbar command palette), only show entries whose `handle.featureFlag` resolves to `true`, and default to visible if no flag is attached.

### Error Handling
- Always handle errors at the appropriate level
- Use React Query's error handling for API errors
- Display user-friendly error messages (internationalized)
- Log errors appropriately for debugging

### Security
- Never commit sensitive data (API keys, tokens, passwords)
- Always validate user input on the server side
- Use environment variables for configuration
- Sanitize user inputs before rendering

### Database
- Use Mongoose schemas for all database models
- Always validate data before saving to database
- Use transactions for operations that must be atomic
- Index frequently queried fields
- All data in the type of files should be save in the supabase. 
- Avoid using base64 and saving them in the DB!

### Date Formatting
- **All dates displayed in the UI must use DD/MM/YYYY format**
- Use the centralized date utilities from `@/lib/dateUtils`:
  - `formatDateForDisplay()` - Formats dates as DD/MM/YYYY
  - `formatDateTimeForDisplay()` - Formats dates as DD/MM/YYYY HH:mm
  - `isDateValue()` - Checks if a value is a date
- **Never format dates directly** - always use these utilities
- When defining table columns with date fields, mark them with `meta: { isDate: true }`
- The data-table component automatically formats dates when:
  1. Column is marked with `meta: { isDate: true }`, OR
  2. The value matches date patterns (detected automatically via `isDateValue()`)
- **Server/DB date format**: Dates are stored as ISO strings in the database - do NOT change this
- **Client display format**: Always DD/MM/YYYY for dates, DD/MM/YYYY HH:mm for date-time

## Testing
- Write E2E tests with Cypress for critical user flows
- Test file naming: `*.cy.ts` (e.g., `form_registration.cy.ts`)
- Focus tests on user interactions and business logic
- Keep tests maintainable and readable

## Code Review Checklist
- [ ] TypeScript types are properly defined
- [ ] All user-facing text is internationalized
- [ ] API errors are handled appropriately
- [ ] Components are properly typed
- [ ] No console.log statements in production code
- [ ] Environment variables are used (not hardcoded)
- [ ] DTOs are used for API endpoints (server)
- [ ] Input validation is present (server)
- [ ] Authentication/authorization is checked (server)

## Common Patterns

### React Native Screen with API (Mobile)
```typescript
import { SafeAreaView } from 'react-native-safe-area-context';
import { useQuery } from '@tanstack/react-query';
import { StyleSheet } from 'react-native';

const HomeScreen = () => {
  const { data, isLoading, error } = useQuery({
    queryKey: ['employees', 'count'],
    queryFn: fetchEmployeesCount,
  });

  return (
    <SafeAreaView style={styles.container}>
      {/* Screen content */}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingHorizontal: 24,
  },
});
```

### React Component with API (Client)
```typescript
// Use React Query for data fetching
const { data, isLoading, error } = useQuery({
  queryKey: ['users'],
  queryFn: () => fetchAllUsers()
});

// Use mutations for data updates
const mutation = useMutation({
  mutationFn: updateUser,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['users'] });
  }
});
```

### React Navigation Pattern (Mobile)
```typescript
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { HomeStackParamList } from '../navigation/AppNavigator';

const MyScreen = () => {
  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList>>();
  
  const handleNavigate = () => {
    navigation.navigate('EmployeesPage');
  };
  
  return (/* ... */);
};
```

### NestJS Controller Pattern
```typescript
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}
  
  @Get()
  @UseGuards(AuthGuard)
  async findAll(@Query() query: FindUsersDto) {
    return this.usersService.findAll(query);
  }
}
```

### Form Handling
- Use React Hook Form with Zod validation
- Use `@hookform/resolvers` for Zod integration
- Extract form logic into custom hooks when reused
- Mobile: Use native TextInput components, ensure proper keyboard handling and safe area considerations

## Dependencies to Prefer
- **UI Components (Client):** shadcn/ui or Radix UI primitives
- **UI Components (Mobile):** Gluestack UI, React Native core components
- **Forms:** React Hook Form + Zod
- **HTTP Client:** Axios (via apiClient)
- **Date Handling:** date-fns or dayjs
- **Icons (Client):** lucide-react
- **Icons (Mobile):** @expo/vector-icons (Feather, etc.)
- **Animations (Client):** framer-motion (when needed)
- **Animations (Mobile):** react-native-reanimated (already included)

## Dependencies to Avoid
- Avoid adding new state management libraries (use React Query + Context)
- Avoid jQuery or other DOM manipulation libraries
- Avoid class-based React components
- Avoid any in production code

## Performance Considerations
- Use React Query's caching effectively
- Implement proper loading and error states
- Lazy load routes when appropriate
- Optimize images and assets
- Use React.memo() only when profiling shows benefit
- Mobile: Use StyleSheet.create() outside render for better performance
- Mobile: Avoid inline styles in render functions
- Mobile: Use FlatList/ScrollView for long lists, implement proper keyExtractor
- Mobile: Consider image optimization and lazy loading for mobile data constraints

## Git Workflow
- Write clear, descriptive commit messages
- Keep commits focused and atomic
- Use feature branches for new work
- Update documentation when adding features

## Documentation
- Document complex business logic
- Add JSDoc comments for public APIs
- Keep README files updated
- Document environment variables needed

