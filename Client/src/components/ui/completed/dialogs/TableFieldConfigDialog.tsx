import { useEffect, useState, useRef } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogBody,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Plus,
  Save,
  Trash,
  X,
  Type,
  Hash,
  Calendar,
  Clock,
  Mail,
  Phone,
  List,
  ListChecks,
  CheckSquare,
  MapPin,
  DollarSign,
  Image,
  File,
  Link as LinkIcon,
  Check,
  ChevronDown,
  LucideIcon,
  Palette,
} from "lucide-react";
import { useTranslation } from "react-i18next";
import { DynamicFieldDefinition } from "@/utils/tableFieldUtils";
import { fetchTableFieldDefinitions, updateTableFieldDefinitions } from "@/api/organizations";
import { toast } from "@/hooks/use-toast";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { cn } from "@/lib/utils";
import { getBadgeColors, normalizeHexColor } from "@/lib/colorUtils";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";

interface TableFieldConfigDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  entityType: string; // "kids", "parents", etc.
  organizationId: string;
  onSave?: () => void;
}

interface FieldChoiceInput {
  id: string;
  label: string;
  value: string;
  color?: string;
}

interface FieldInput {
  name: string;
  label: string;
  type:
    | "TEXT"
    | "SELECT"
    | "DATE"
    | "NUMBER"
    | "EMAIL"
    | "PHONE"
    | "MULTI_SELECT"
    | "TIME"
    | "CHECKBOX"
    | "ADDRESS"
    | "MONEY"
    | "IMAGE"
    | "FILE"
    | "LINK";
  required: boolean;
  choices?: FieldChoiceInput[];
  isNameAutoGenerated?: boolean;
}

// Field type configuration with icons
interface FieldTypeOption {
  value: FieldInput["type"];
  label: string;
  icon: LucideIcon;
}

const OPTION_COLOR_PRESETS = [
  "#F87171",
  "#FB923C",
  "#FBBF24",
  "#34D399",
  "#38BDF8",
  "#818CF8",
] as const;

const DEFAULT_OPTION_COLOR = OPTION_COLOR_PRESETS[0];

const generateChoiceId = () => {
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  return `choice-${Math.random().toString(36).slice(2, 10)}`;
};

const getPresetColor = (index: number) =>
  OPTION_COLOR_PRESETS[index % OPTION_COLOR_PRESETS.length];

const normalizeDefinitionChoices = (
  choices: any[] | undefined,
  fieldName: string
): FieldChoiceInput[] => {
  if (!Array.isArray(choices)) {
    return [];
  }

  return choices
    .map((choice, index) => {
      if (typeof choice === "string") {
        return {
          id: `${fieldName}-${index}-${generateChoiceId()}`,
          label: choice,
          value: choice,
        };
      }

      const label = choice?.label ?? choice?.value ?? "";
      const value = choice?.value ?? choice?.label ?? "";

      if (!label || !value) {
        return null;
      }

      return {
        id: `${fieldName}-${index}-${generateChoiceId()}`,
        label,
        value,
        color: normalizeHexColor(choice?.color),
      };
    })
    .filter((choice): choice is FieldChoiceInput => Boolean(choice?.value));
};

const slugifyFieldName = (value: string): string => {
  return value
    .trim()
    .toLowerCase()
    .replace(/\s+/g, "_")
    .replace(/[^\p{Letter}\p{Number}_]/gu, "")
    .replace(/_+/g, "_")
    .replace(/^_+|_+$/g, "");
};

const ensureUniqueFieldName = (
  baseName: string,
  index: number,
  fields: FieldInput[]
): string => {
  const fallback = baseName || `field_${index + 1}`;
  const existingNames = fields
    .map((field, i) => (i === index ? null : field.name?.trim()))
    .filter((name): name is string => Boolean(name && name.length > 0));

  if (!existingNames.includes(fallback)) {
    return fallback;
  }

  let suffix = 2;
  let candidate = `${fallback}_${suffix}`;
  while (existingNames.includes(candidate)) {
    suffix += 1;
    candidate = `${fallback}_${suffix}`;
  }
  return candidate;
};

// Component for adding new choices
interface ChoiceInputProps {
  onAddChoice: (value: string) => void;
  placeholder?: string;
  existingChoices: FieldChoiceInput[];
}

function ChoiceInput({ onAddChoice, placeholder, existingChoices }: ChoiceInputProps) {
  const [inputValue, setInputValue] = useState("");
  const inputRef = useRef<HTMLInputElement>(null);

  const exists = (value: string) =>
    existingChoices.some(
      (choice) => choice.label.toLowerCase() === value.trim().toLowerCase()
    );

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter" && inputValue.trim()) {
      e.preventDefault();
      if (!exists(inputValue)) {
        onAddChoice(inputValue.trim());
        setInputValue("");
      }
    }
  };

  const handleAddClick = () => {
    if (inputValue.trim() && !exists(inputValue)) {
      onAddChoice(inputValue.trim());
      setInputValue("");
      inputRef.current?.focus();
    }
  };

  return (
    <div className="flex items-center gap-2">
      <input
        ref={inputRef}
        type="text"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder={placeholder}
        className="flex-1 border rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-800 dark:border-gray-600 dark:text-white"
      />
      <Button
        type="button"
        variant="outline"
        size="sm"
        onClick={handleAddClick}
        disabled={!inputValue.trim() || exists(inputValue)}
        className="shrink-0"
      >
        <Plus className="w-4 h-4" />
      </Button>
    </div>
  );
}

// Field Type Selector Component with autocomplete and icons
interface FieldTypeSelectorProps {
  value: FieldInput["type"];
  onChange: (value: FieldInput["type"]) => void;
  t: ReturnType<typeof useTranslation>["t"];
}

function FieldTypeSelector({ value, onChange, t }: FieldTypeSelectorProps) {
  const [open, setOpen] = useState(false);

  const fieldTypes: FieldTypeOption[] = [
    { value: "TEXT", label: t("text", "Text"), icon: Type },
    { value: "NUMBER", label: t("number", "Number"), icon: Hash },
    { value: "DATE", label: t("date", "Date"), icon: Calendar },
    { value: "TIME", label: t("time", "Time"), icon: Clock },
    { value: "EMAIL", label: t("email", "Email"), icon: Mail },
    { value: "PHONE", label: t("phone", "Phone"), icon: Phone },
    { value: "SELECT", label: t("select", "Select"), icon: List },
    { value: "MULTI_SELECT", label: t("multi_select", "Multiple Choice"), icon: ListChecks },
    { value: "CHECKBOX", label: t("checkbox", "Checkbox"), icon: CheckSquare },
    { value: "ADDRESS", label: t("address", "Address"), icon: MapPin },
    { value: "MONEY", label: t("money", "Money"), icon: DollarSign },
    { value: "IMAGE", label: t("image", "Image"), icon: Image },
    { value: "FILE", label: t("file", "File"), icon: File },
    { value: "LINK", label: t("link", "Link"), icon: LinkIcon },
  ];

  const selectedField = fieldTypes.find((ft) => ft.value === value);
  const SelectedIcon = selectedField?.icon || Type;

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className="w-[200px] justify-between hover:bg-blue-50 hover:text-blue-700 dark:hover:bg-blue-900/20 dark:hover:text-blue-300"
        >
          <div className="flex items-center gap-2">
            <SelectedIcon className="h-4 w-4 shrink-0" />
            <span className="truncate">{selectedField?.label || t("text", "Text")}</span>
          </div>
          <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-[200px] p-0" align="start">
        <Command>
          <CommandInput placeholder={t("search_field_type", "חפש סוג שדה...")} />
          <CommandList className="max-h-[300px] overflow-y-auto overflow-x-hidden">
            <CommandEmpty>{t("no_field_type_found", "לא נמצא סוג שדה.")}</CommandEmpty>
            <CommandGroup>
              {fieldTypes.map((fieldType) => {
                const Icon = fieldType.icon;
                const isSelected = value === fieldType.value;
                return (
                  <CommandItem
                    key={fieldType.value}
                    value={`${fieldType.value} ${fieldType.label}`}
                    onSelect={() => {
                      onChange(fieldType.value);
                      setOpen(false);
                    }}
                    className={cn(
                      "cursor-pointer transition-colors",
                      "hover:bg-blue-50 hover:text-blue-700 dark:hover:bg-blue-900/20 dark:hover:text-blue-300",
                      isSelected && "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300"
                    )}
                  >
                    <Check
                      className={cn(
                        "mr-2 h-4 w-4",
                        isSelected ? "opacity-100" : "opacity-0"
                      )}
                    />
                    <Icon className="mr-2 h-4 w-4" />
                    {fieldType.label}
                  </CommandItem>
                );
              })}
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}

export function TableFieldConfigDialog({
  open,
  onOpenChange,
  entityType,
  organizationId,
  onSave,
}: TableFieldConfigDialogProps) {
  const { t } = useTranslation();
  const queryClient = useQueryClient();
  const [fields, setFields] = useState<FieldInput[]>([]);
  const [loading, setLoading] = useState(false);

  // React Query mutation with automatic cache invalidation
  const updateMutation = useMutation({
    mutationFn: async (updatedDefinitions: Record<string, any>) => {
      return await updateTableFieldDefinitions(organizationId, updatedDefinitions);
    },
    onSuccess: () => {
      // Automatically invalidate and refetch organization data
      // This will trigger a refetch of the organization query, which will update mergedColumns
      queryClient.invalidateQueries({ queryKey: ["organization"] });
      toast.success(t("saved_successfully") || "Field definitions saved successfully");
      onSave?.();
      onOpenChange(false);
    },
    onError: (error) => {
      console.error("Error saving table field definitions:", error);
      toast.error(t("error") || "Failed to save field definitions");
    },
  });

  useEffect(() => {
    if (!open || !organizationId) return;

    const fetchDefinitions = async () => {
      try {
        setLoading(true);
        const res = await fetchTableFieldDefinitions(organizationId);
        if (res.data?.[entityType]?.fields) {
          const fieldDefs = res.data[entityType].fields;
          const fieldInputs: FieldInput[] = Object.entries(fieldDefs).map(([name, def]: [string, any]) => ({
            name,
            label: def.label || name,
            type: def.type || "TEXT",
            required: def.required || false,
            choices: normalizeDefinitionChoices(def.choices, name),
            isNameAutoGenerated: false,
          }));
          setFields(fieldInputs);
        } else {
          setFields([]);
        }
      } catch (error) {
        console.error("Error fetching table field definitions:", error);
        toast.error(t("error") || "Failed to load field definitions");
      } finally {
        setLoading(false);
      }
    };

    fetchDefinitions();
  }, [open, entityType, organizationId]);

  const handleAddField = () => {
    setFields([
      ...fields,
      {
        name: "",
        label: "",
        type: "TEXT",
        required: false,
        isNameAutoGenerated: true,
      },
    ]);
  };

  const handleRemoveField = (index: number) => {
    setFields(fields.filter((_, i) => i !== index));
  };

  const handleFieldChange = (index: number, updates: Partial<FieldInput>) => {
    const newFields = [...fields];
    const previousField = newFields[index];
    const updatedField: FieldInput = { ...previousField, ...updates };

    if (updates.label !== undefined) {
      const generatedSlug = slugifyFieldName(updates.label);
      const previousSlug = slugifyFieldName(previousField.label || "");
      const shouldRegenerateName =
        !previousField.name ||
        previousField.name === previousSlug ||
        previousField.isNameAutoGenerated;

      if (shouldRegenerateName) {
        updatedField.name = ensureUniqueFieldName(generatedSlug, index, newFields);
        updatedField.isNameAutoGenerated = true;
      } else {
        updatedField.isNameAutoGenerated = false;
      }
    }

    newFields[index] = updatedField;
    
    // Handle SELECT/MULTI_SELECT type changes
    if ((updates.type === "SELECT" || updates.type === "MULTI_SELECT") && !newFields[index].choices) {
      newFields[index].choices = [];
    }
    if (updates.type !== "SELECT" && updates.type !== "MULTI_SELECT") {
      newFields[index].choices = undefined;
    }
    
    setFields(newFields);
  };

  const handleAddChoice = (index: number, choiceValue: string) => {
    if (!choiceValue.trim()) return;
    
    const newFields = [...fields];
    const currentChoices = newFields[index].choices || [];
    
    // Check if choice already exists
    if (
      currentChoices.some(
        (choice) => choice.label.toLowerCase() === choiceValue.trim().toLowerCase()
      )
    ) {
      toast.error(t("choice_already_exists", "This option already exists"));
      return;
    }
    
    const nextChoice: FieldChoiceInput = {
      id: generateChoiceId(),
      label: choiceValue.trim(),
      value: choiceValue.trim(),
      color: getPresetColor(currentChoices.length),
    };
    
    newFields[index].choices = [...currentChoices, nextChoice];
    setFields(newFields);
  };

  const handleRemoveChoice = (index: number, choiceIndex: number) => {
    const newFields = [...fields];
    const currentChoices = newFields[index].choices || [];
    currentChoices.splice(choiceIndex, 1);
    newFields[index].choices = currentChoices;
    setFields(newFields);
  };

  const handleChoiceColorChange = (index: number, choiceId: string, color: string) => {
    const normalized = normalizeHexColor(color) ?? DEFAULT_OPTION_COLOR;
    setFields((prev) => {
      const next = [...prev];
      const field = next[index];
      if (!field?.choices) {
        return prev;
      }
      next[index] = {
        ...field,
        choices: field.choices.map((choice) =>
          choice.id === choiceId ? { ...choice, color: normalized } : choice
        ),
      };
      return next;
    });
  };

  const handleSubmit = async () => {
    if (!organizationId) return;

    // Validate fields
    const invalidFields = fields.filter(
      (f) => !f.name.trim() || !f.label.trim() || ((f.type === "SELECT" || f.type === "MULTI_SELECT") && (!f.choices || f.choices.length === 0))
    );

    if (invalidFields.length > 0) {
      toast.error(t("invalid_fields") || "Please fill in all required fields");
      return;
    }

    try {
      setLoading(true);
      
      // Fetch current definitions
      const res = await fetchTableFieldDefinitions(organizationId);
      const currentDefinitions = res.data || {};
      
      // Build field definitions object
      const fieldDefinitions: Record<string, DynamicFieldDefinition> = {};
      fields.forEach((field) => {
        const fieldType = field.type as DynamicFieldDefinition["type"];
        const fieldDef: DynamicFieldDefinition = {
          type: fieldType,
          label: field.label,
          required: field.required,
        };
        
        if ((field.type === "SELECT" || field.type === "MULTI_SELECT") && field.choices) {
          fieldDef.choices = field.choices
            .filter((choice) => choice.label && choice.value)
            .map((choice) => ({
              label: choice.label,
              value: choice.value,
              ...(choice.color ? { color: choice.color } : {}),
            }));
        }
        
        fieldDefinitions[field.name] = fieldDef;
      });

      // Update definitions for this entity type
      const updatedDefinitions = {
        ...currentDefinitions,
        [entityType]: {
          fields: fieldDefinitions,
        },
      };

      // Use mutation instead of direct API call
      // This will automatically invalidate the organization query and refetch it
      await updateMutation.mutateAsync(updatedDefinitions);
    } catch (error) {
      // Error is handled by mutation's onError callback
    } finally {
      setLoading(false);
    }
  };

  const resetForm = () => {
    setFields([]);
  };

  return (
    <Dialog
      open={open}
      onOpenChange={(value) => {
        if (!value) {
          resetForm();
          onOpenChange(false);
        }
      }}
    >
      <DialogContent className="max-w-4xl max-h-[90vh] p-0 flex flex-col">
        <DialogHeader className="sticky top-0 z-10 bg-background border-b flex-shrink-0">
          <DialogTitle className="text-center text-2xl">
            {t("configure_dynamic_fields", "עדכן שדות דינאמיים")} - {t(entityType)}
          </DialogTitle>
        </DialogHeader>

        <DialogBody className="flex-1 overflow-y-auto p-6">
          <div className="space-y-4">
            {loading && fields.length === 0 ? (
              <div className="text-center py-4">{t("loading") || "Loading..."}</div>
            ) : (
              <>
                {fields.map((field, index) => (
                  <div key={index} className="flex flex-col gap-2 border rounded p-4">
                    <div className="flex items-center gap-2">
                      <div className="flex-1 space-y-2">
                        <input
                          type="text"
                          value={field.label}
                          onChange={(e) =>
                            handleFieldChange(index, { label: e.target.value })
                          }
                          placeholder={t("field_label", "Field Label")}
                          className="w-full border rounded px-3 py-2"
                        />
                      </div>
                      <FieldTypeSelector
                        value={field.type}
                        onChange={(newType) =>
                          handleFieldChange(index, { type: newType })
                        }
                        t={t}
                      />
                      <div className="flex items-center gap-3">
                        <div className="flex items-center gap-2">
                          <Checkbox
                            id={`required-${index}`}
                            checked={field.required}
                            onCheckedChange={(checked) =>
                              handleFieldChange(index, { required: checked === true })
                            }
                          />
                          <label
                            htmlFor={`required-${index}`}
                            className="text-sm font-medium cursor-pointer whitespace-nowrap"
                          >
                            {t("required_field", "שדה חובה")}
                          </label>
                        </div>
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          onClick={() => handleRemoveField(index)}
                          className="h-9 w-9 text-red-500 hover:text-red-600 hover:bg-red-50 dark:hover:bg-red-950/20"
                        >
                          <Trash className="h-5 w-5" />
                        </Button>
                      </div>
                    </div>

                    {(field.type === "SELECT" || field.type === "MULTI_SELECT") && (
                      <div className="mt-3 space-y-3">
                        <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                          {t("select_options", "Select Options")}
                        </label>
                        
                        {/* Display existing choices as chips */}
                        {field.choices && field.choices.length > 0 && (
                          <div className="space-y-2">
                            {field.choices.map((choice, choiceIndex) => {
                              const { background, text } = getBadgeColors(choice.color);
                              const colorValue = normalizeHexColor(choice.color) ?? background;
                              
                              return (
                                <div
                                  key={choice.id}
                                  className="flex flex-wrap items-center justify-between gap-3 rounded-xl border border-gray-200 bg-white/80 p-3 dark:border-gray-700 dark:bg-slate-900/60"
                                >
                                  <div className="flex flex-col gap-1">
                                    <span
                                      className="inline-flex items-center gap-2 rounded-full border px-3 py-1 text-xs font-semibold shadow-sm"
                                      style={{
                                        backgroundColor: background,
                                        color: text,
                                        borderColor: background,
                                      }}
                                    >
                                      {choice.label}
                                    </span>
                                    <span className="text-xs text-muted-foreground dark:text-slate-400">
                                      {t("value", "ערך")}: {choice.value}
                                    </span>
                                  </div>
                                  <div className="flex items-center gap-2">
                                    <div className="flex flex-wrap gap-2">
                                      {OPTION_COLOR_PRESETS.map((presetColor) => {
                                        const isSelected = colorValue === normalizeHexColor(presetColor);
                                        const { background: presetBg, text: presetText } = getBadgeColors(presetColor);
                                        return (
                                          <button
                                            key={`${choice.id}-${presetColor}`}
                                            type="button"
                                            onClick={() => handleChoiceColorChange(index, choice.id, presetColor)}
                                            className={cn(
                                              "h-9 w-9 rounded-full border-2 transition-transform hover:scale-105 focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2",
                                              isSelected ? "border-primary ring-2 ring-primary/40" : "border-transparent"
                                            )}
                                            style={{ backgroundColor: presetBg, color: presetText }}
                                            aria-label={t("select_color", "בחר צבע")}
                                          >
                                            {isSelected && <Check className="h-4 w-4" />}
                                          </button>
                                        );
                                      })}
                                    </div>
                                    <Button
                                      type="button"
                                      variant="ghost"
                                      size="icon"
                                      onClick={() => handleRemoveChoice(index, choiceIndex)}
                                      className="h-8 w-8 text-red-500 hover:text-red-600 hover:bg-red-50 dark:hover:bg-red-900/30"
                                      aria-label={t("remove_option", "Remove option")}
                                    >
                                      <X className="h-4 w-4" />
                                    </Button>
                                  </div>
                                </div>
                              );
                            })}
                          </div>
                        )}
                        
                        {/* Input for adding new choices */}
                        <ChoiceInput
                          onAddChoice={(value) => handleAddChoice(index, value)}
                          placeholder={t("add_option_placeholder", "Type an option and press Enter")}
                          existingChoices={field.choices || []}
                        />
                      </div>
                    )}
                  </div>
                ))}
              </>
            )}
          </div>
        </DialogBody>

        <DialogFooter className="sticky bottom-0 z-10 bg-background border-t flex-shrink-0 flex justify-center gap-2">
          <Button
            type="button"
            variant="outline"
            onClick={handleAddField}
            className="flex items-center gap-2 bg-green-600 hover:bg-green-700 text-white hover:text-white border-green-600 hover:border-green-700 shadow-md hover:shadow-lg transition-all duration-200 font-medium"
          >
            <Plus className="w-4 h-4" />
            {t("add_field", "Add Field")}
          </Button>
          <Button 
            onClick={handleSubmit} 
            disabled={loading || updateMutation.isPending} 
            className="flex gap-2"
          >
            <Save className="w-4 h-4" />
            {t("save", "Save")}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

